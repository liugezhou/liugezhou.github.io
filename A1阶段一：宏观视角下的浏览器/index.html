<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="六个周的博客"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="六个周"><meta name="twitter:creator" content="@liugezhou"><meta name="twitter:title" content="阶段一：宏观视角下的浏览器"><meta name="twitter:description" content="&lt;h2 id=&quot;01-Chrome架构：仅仅打开了1个页面，为什么有4个进程？&quot;&gt;01 | Chrome架构：仅仅打开了1个页面，为什么有4个进程？&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一、操作&quot;&gt;一、操作&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在Chrome浏览器中，我们点击右上角三个点–更多工具–任务管理器。&lt;br&gt;
会看到打开一个页面，启动了多个进程。&lt;br&gt;
在进行每个进程分析前，先明确下线程与进程之间的关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;二、线程-VS-进程&quot;&gt;二、线程 VS 进程&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;进程：一个进程就是一个运行实例–启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，这样的一个运行环境就叫做进程。&lt;/li&gt;
&lt;li&gt;线程：线程不能单独存在，需要由进程来启动和管理。&lt;br&gt;
线程与进程的关系：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;进程中任一线程执行出错，整个进程都会崩溃。&lt;/li&gt;
&lt;li&gt;线程之间共享进程中的数据。&lt;/li&gt;
&lt;li&gt;当一个进程关闭之后，操作系统会回收进程所占用的内存。&lt;/li&gt;
&lt;li&gt;进程之间的内容相互隔离。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;三、单进程浏览器时代&quot;&gt;三、单进程浏览器时代&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;单进程浏览器是指所有功能模块(网路、插件、JS运行环境、渲染引擎等)都是运行在同一个进程里，2007年以前，市面上浏览器都是单进程架构。&lt;br&gt;
这种结构模式：不稳定、不流畅、不安全。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;四、多进程浏览器时代&quot;&gt;四、多进程浏览器时代&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;进程之间通过IPC机制进行通信&lt;/li&gt;
&lt;li&gt;不稳定问题解决：由于进程的隔离性，当一个页面或插件崩溃时，不会影响到浏览器的其他页面&lt;/li&gt;
&lt;li&gt;不流畅问题解决：即使JS的执行阻塞了渲染进程，也只是影响当前页面&lt;/li&gt;
&lt;li&gt;不安全问题解决：安全沙箱&lt;br&gt;
最新的Chrome浏览器包括：&lt;strong&gt;一个浏览器主进程&lt;/strong&gt;、&lt;strong&gt;一个GPU进程&lt;/strong&gt;、&lt;strong&gt;一个网络进程&lt;/strong&gt;、&lt;strong&gt;多个渲染进程&lt;/strong&gt;和&lt;strong&gt;多个插件进程&lt;/strong&gt;。&lt;br&gt;
存在问题：更高的资源占用和更复杂的体系结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;五、未来面向服务的架构&quot;&gt;五、未来面向服务的架构&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;2016年，Chrome官方团队使用“面向服务的架构”(SOA)的思想设计了新的Chrome架构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;02-TCP协议：如何保证页面文件能被完整送达浏览器？&quot;&gt;02 | TCP协议：如何保证页面文件能被完整送达浏览器？&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;衡量web性能的一个重要指标叫&amp;quot;FP(First Paint)&amp;quot;,指页面加载到首次开始绘制的时长。影响FP的重要因素有一个网络加载速度。&lt;br&gt;
网络加载的过程就是数据包的传输过程，站在数据包角度，从“数据包如何送达主机”，“主机如何将数据包转交给应用”，“数据如何被完整送达应用程序”三个方面来分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、IP：把数据包送达目的主机&quot;&gt;一、IP：把数据包送达目的主机&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;数据包要在互联网上进行传输，要符合&lt;strong&gt;网际协议IP(Internet Protocol)标准&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;计算机的地址称为IP地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。&lt;/li&gt;
&lt;li&gt;IP头是IP数据包开头的信息，包含IP版本、源IP地址、目标IP地址、生存时间等信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;二、UDP：把数据包送达应用程序&quot;&gt;二、UDP：把数据包送达应用程序&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;IP是非常底层的协议，只负责把数据包传达给目标主机，但是并不知道交给哪个应用程序。&lt;br&gt;
因此需要基于IP之上开发能和应用打交道的协议，最常见的协议就是&lt;strong&gt;UDP协议–User Datagram Protocol(用户数据包协议)&lt;/strong&gt;&lt;br&gt;
UDP通过端口号把数据包分发给正确的程序。&lt;br&gt;
UDP可以校验数据是否正确，但是不提供重传机制，只是丢弃当前的包。虽然UDP不能保证数据的准确性，但是传输速度非常快。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;三、TCP：把数据完整的送达应用程序&quot;&gt;三、TCP：把数据完整的送达应用程序&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP(Transition Control Protocol,传输控制协议)，是一种面向连接的、可靠的、基于字节流的传输层通信协议。&lt;br&gt;
TCP提供重传机制、引入了数据包排序机制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;一个完整的TCP连接的生命周期包含了“建立连接“、”传输数据“、“断开连接”三个阶段。&lt;br&gt;
建立连接阶段：这个阶段通过三次握手来建立客户端与服务端之间的连接，它们之间总共要发送三个数据包以确认连接的建立。&lt;br&gt;
传输数据阶段：该阶段，接收端需要对每个数据包进行确认操作。&lt;br&gt;
断开连接阶段：四次挥手来保证双方都能断开连接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;03｜HTTP请求流程：为什么很多站点第二次打开速度会很快&quot;&gt;03｜HTTP请求流程：为什么很多站点第二次打开速度会很快&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP协议是建立在TCP连接基础之上的。&lt;br&gt;
HTTP是一种允许浏览器向服务器获取资源的协议，是Web的基础。&lt;br&gt;
浏览器端发起HTTP请求流程如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、构建请求&quot;&gt;一、构建请求&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;浏览器构建请求行信息，构建好后，浏览器准备发起网络请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;二、查找缓存&quot;&gt;二、查找缓存&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在准备发起网路请求阶段，浏览器偷偷的在它的缓存中查询是否有要请求的资源。&lt;br&gt;
若有：拦截请求，返回资源副本，直接结束请求。&lt;br&gt;
若缓存查找失败：继续下一步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;三、准备IP地址和端口号&quot;&gt;三、准备IP地址和端口号&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;浏览器第一步会请求域名系统DNS返回域名对应的IP，如果没有特别指明端口号，则默认为80。 (浏览器提供了DNS数据缓存服务，若缓存过也就不会去请求，直接解析。从而减少一次网络请求)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;四、等待TCP队列&quot;&gt;四、等待TCP队列&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;拿到IP地址与端口号后，还需要在TCP队列中排队才能建立TCP连接。&lt;br&gt;
这是因为：Chrome有个机制，同一个域名同时最多只能建立6个TCP连接，若此刻同时有10个请求发生。则四个会进入TCP队列进行排队。 当然，若当前请求数量少于6个，则会直接进入下一步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;五、建立TCP连接&quot;&gt;五、建立TCP连接&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;建立TCP连接，上一节我们已经知道，一个完整的TCP连接过程包括“建立连接”、“数据传输”、“断开连接“三个阶段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;六、发送HTTP请求&quot;&gt;六、发送HTTP请求&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP请求是在TCP连接的数据传输阶段工作的，这个时候浏览器向服务器发送&lt;em&gt;请求行&lt;/em&gt;，它包括请求方法、请求URI、HTTP版本协议。HTTP中的数据在这个通信过程中传输。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;七、服务端处理HTTP请求流程&quot;&gt;七、服务端处理HTTP请求流程&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;返回请求：通过 ‘curl -i domainName’命令，可以返回响应行(协议版本和状态码)、响应头(服务端返回请求的时间、Cookie、返回的数据类型等)、响应体信息.&lt;br&gt;
通常情况，一旦服务器向客户端返回了请求数据，它就要关闭TCP连接，但是如果浏览器或者服务器设置了Connection:keep-alive，那么TCP连接在发送后将仍保持打开状态。保持TCP连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;八、问题解答&quot;&gt;八、问题解答&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;为什么很多站点第二次打开速度会很快？&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;主要原因肯定是第一次加载页面的过程中，缓存了一些数据(从上面的过程分析，我们知道DNS缓存和页面资源缓存这两块数据是会被浏览器缓存起来的).&lt;br&gt;
网站把很多资源都缓存到了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;登录状态是如何保持的&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;04-导航流程：从输入URL到页面展示，这中间发生了什么？&quot;&gt;04| 导航流程：从输入URL到页面展示，这中间发生了什么？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;从输入URL到页面展示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-用户输入&quot;&gt;1.用户输入&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;如果是搜索内容，地址栏使用浏览器默认的搜索引擎合成带关键字的URL，如果符合URL规则，则合成完整的URL。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2-URL请求过程&quot;&gt;2.URL请求过程&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;浏览器主进程通过进程间通信(IPC)把URL请求发送到网络进程，网络进程接收到URL请求后，会发起真正的URL请求。&lt;br&gt;
首先，浏览器会查找本地缓存是否缓存了该资源，如果缓存则直接返回资源给浏览器主进程，如果没有缓存，那么直接进入网络请求流程：请求前的第一步是DNS解析，用来获取域名对应的IP地址，如果是HTTPS协议，还需要建立TLS连接。&lt;br&gt;
接下来就是利用IP地址和服务器建立TCP连接，连接建立后，浏览器端会构建请求行、请求头等信息。&lt;br&gt;
服务器接收到请求信息后，根据请求信息生成响应行、响应头发给网络进程。网络进程接收到后，开始解析响应数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;3-准备渲染进程&quot;&gt;3.准备渲染进程&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;同一站点：协议相同、根域名相同。&lt;br&gt;
通常情况下，打开一个新的页面，浏览器就会为开辟一个新的渲染进程，但若从A页面打开的B页面，它们同属同一站点，那么使用同一渲染进程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;4-提交文档&quot;&gt;4.提交文档&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;浏览器进程将网络进程接受到的HTML数据提交给渲染进程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;5-渲染阶段&quot;&gt;5.渲染阶段&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;一旦文档被提交，渲染进程就开始页面解析和子资源加载了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;05-渲染流程-HTML、CSS和JAVASCRIPT是如何变成页面的？&quot;&gt;05| 渲染流程:HTML、CSS和JAVASCRIPT是如何变成页面的？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;按照渲染的时间顺序，流水线可以分为：构建DOM树、样式计算、布局计算、分层、绘制、分块、光栅化、合成。&lt;br&gt;
每个阶段需要关注：输入的内容、处理过程、输出的内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-构建DOM树&quot;&gt;1.构建DOM树&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;因为浏览器无法直接理解和使用HTML，所以需要将HTML转换为浏览器能够理解的结构–DOM树。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入内容是HTML文件&lt;/li&gt;
&lt;li&gt;经过HTML解析器解析&lt;/li&gt;
&lt;li&gt;输出树状的DOM结构–DOM树结构与HTML内容几乎一模一样，但DOM是保存在内存中树状结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2-样式计算&quot;&gt;2.样式计算&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;样式计算的目的是为了计算出DOM节点中每个元素的具体样式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入内容是CSS文件&lt;/li&gt;
&lt;li&gt;处理过程是将CSS文件进行转换成浏览器可以理解的结构–styleSheets、对属性值进行标准化(em-px,red-rgb,bold-700)、计算DOM树中每个节点的样式属性(css继承和层叠规则)&lt;/li&gt;
&lt;li&gt;输出了经过处理的styleSheets&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;3-布局阶段&quot;&gt;3.布局阶段&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;DOM结构有了、样式结构有了，需要对几何位置信息进行布局。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建布局树(DOM结构与样式结构结合，将display为none的去除，构成布局树)&lt;/li&gt;
&lt;li&gt;布局计算(输入为布局树，经过复杂计算，输出也为布局树)、由于输入输出一致，因此Google下一代布局系统的优化叫做LayoutNG。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;4-分层&quot;&gt;4.分层&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;页面开始绘制之前，浏览器会对3D变换、页面滚动、z-index等操作去为特定的节点生产专用的图层、并生成一颗对应的图层树。&lt;br&gt;
结果是：最终每一个节点都会直接或间接的从属于一个层。&lt;br&gt;
满足分层有两个条件：用于层叠上下文属性(定位属性、透明属性、滤镜等)和需要裁剪的地方(overflow)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;5-图层绘制&quot;&gt;5.图层绘制&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;将图层绘制命令拆分为很多小的绘制指令，然后一个个执行这些命令，汇总成待绘制列表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;6-栅格化操作&quot;&gt;6.栅格化操作&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有了这些绘制命令、浏览器渲染引擎中的合成线程进行绘制。&lt;br&gt;
所谓栅格化操作就是按照视口附近的图块优先生成位图。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;7-合成和显示&quot;&gt;7.合成和显示&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;浏览器进程通过via组件，接收合成线程发过来的绘制图块命令，将页面绘制到内存中，显示在屏幕上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;相关概念&quot;&gt;相关概念&lt;/h3&gt;
&lt;h4 id=&quot;重排&quot;&gt;重排&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;改变了元素长宽、浏览器会出发重新布局–后续一系列过程，会更新完成的渲染流水线，因此开销最大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;重绘&quot;&gt;重绘&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;改变了颜色等未引起几何位置变化，重绘相较重排、省去了布局和分层阶段，因此效率会高一些。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;直接合成&quot;&gt;直接合成&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;比如CSS的transform实现的动画效果，可以避开重排和重绘阶段，大大提升绘制效率。&lt;/p&gt;
&lt;/blockquote&gt;
"><meta name="twitter:image"><title>阶段一：宏观视角下的浏览器 | 六个周</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.3"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + '912656f1f71687bc80e68bfc7315fc4c';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">阶段一：宏观视角下的浏览器</h1><a id="logo" href="/.">六个周</a><p class="description">一个人只有一种命运，早日相遇，尽情拥抱。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa fa-subway"> 开往</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">阶段一：宏观视角下的浏览器</h1><div class="post-meta">2022-03-23<span> | </span><span class="category"><a href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">浏览器工作原理</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.3k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 11</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" href="/A1%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/#vcomment"><span class="valine-comment-count" data-xid="/A1%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-Chrome%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%BB%85%E4%BB%85%E6%89%93%E5%BC%80%E4%BA%861%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%894%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-text">01 | Chrome架构：仅仅打开了1个页面，为什么有4个进程？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%93%8D%E4%BD%9C"><span class="toc-text">一、操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B-VS-%E8%BF%9B%E7%A8%8B"><span class="toc-text">二、线程 VS 进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8D%95%E8%BF%9B%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E4%BB%A3"><span class="toc-text">三、单进程浏览器时代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E4%BB%A3"><span class="toc-text">四、多进程浏览器时代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%9C%AA%E6%9D%A5%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-text">五、未来面向服务的架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-TCP%E5%8D%8F%E8%AE%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%A1%B5%E9%9D%A2%E6%96%87%E4%BB%B6%E8%83%BD%E8%A2%AB%E5%AE%8C%E6%95%B4%E9%80%81%E8%BE%BE%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9F"><span class="toc-text">02 | TCP协议：如何保证页面文件能被完整送达浏览器？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81IP%EF%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E9%80%81%E8%BE%BE%E7%9B%AE%E7%9A%84%E4%B8%BB%E6%9C%BA"><span class="toc-text">一、IP：把数据包送达目的主机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81UDP%EF%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E9%80%81%E8%BE%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">二、UDP：把数据包送达应用程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81TCP%EF%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E7%9A%84%E9%80%81%E8%BE%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">三、TCP：把数据完整的送达应用程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03%EF%BD%9CHTTP%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%AB%99%E7%82%B9%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%89%93%E5%BC%80%E9%80%9F%E5%BA%A6%E4%BC%9A%E5%BE%88%E5%BF%AB"><span class="toc-text">03｜HTTP请求流程：为什么很多站点第二次打开速度会很快</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%9E%84%E5%BB%BA%E8%AF%B7%E6%B1%82"><span class="toc-text">一、构建请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%9F%A5%E6%89%BE%E7%BC%93%E5%AD%98"><span class="toc-text">二、查找缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%87%86%E5%A4%87IP%E5%9C%B0%E5%9D%80%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">三、准备IP地址和端口号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%AD%89%E5%BE%85TCP%E9%98%9F%E5%88%97"><span class="toc-text">四、等待TCP队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5"><span class="toc-text">五、建立TCP连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%8F%91%E9%80%81HTTP%E8%AF%B7%E6%B1%82"><span class="toc-text">六、发送HTTP请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="toc-text">七、服务端处理HTTP请求流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94"><span class="toc-text">八、问题解答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-%E5%AF%BC%E8%88%AA%E6%B5%81%E7%A8%8B%EF%BC%9A%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">04| 导航流程：从输入URL到页面展示，这中间发生了什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5"><span class="toc-text">1.用户输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-URL%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="toc-text">2.URL请求过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%87%86%E5%A4%87%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B"><span class="toc-text">3.准备渲染进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8F%90%E4%BA%A4%E6%96%87%E6%A1%A3"><span class="toc-text">4.提交文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5"><span class="toc-text">5.渲染阶段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-HTML%E3%80%81CSS%E5%92%8CJAVASCRIPT%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90%E9%A1%B5%E9%9D%A2%E7%9A%84%EF%BC%9F"><span class="toc-text">05| 渲染流程:HTML、CSS和JAVASCRIPT是如何变成页面的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9E%84%E5%BB%BADOM%E6%A0%91"><span class="toc-text">1.构建DOM树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%B7%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="toc-text">2.样式计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%83%E5%B1%80%E9%98%B6%E6%AE%B5"><span class="toc-text">3.布局阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%86%E5%B1%82"><span class="toc-text">4.分层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9B%BE%E5%B1%82%E7%BB%98%E5%88%B6"><span class="toc-text">5.图层绘制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%A0%85%E6%A0%BC%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-text">6.栅格化操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%90%88%E6%88%90%E5%92%8C%E6%98%BE%E7%A4%BA"><span class="toc-text">7.合成和显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E6%8E%92"><span class="toc-text">重排</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E7%BB%98"><span class="toc-text">重绘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%90%88%E6%88%90"><span class="toc-text">直接合成</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><h2 id="01-Chrome架构：仅仅打开了1个页面，为什么有4个进程？">01 | Chrome架构：仅仅打开了1个页面，为什么有4个进程？</h2>
<hr>
<h3 id="一、操作">一、操作</h3>
<blockquote>
<p>在Chrome浏览器中，我们点击右上角三个点–更多工具–任务管理器。<br>
会看到打开一个页面，启动了多个进程。<br>
在进行每个进程分析前，先明确下线程与进程之间的关系。</p>
</blockquote>
<h3 id="二、线程-VS-进程">二、线程 VS 进程</h3>
<blockquote>
<ul>
<li>进程：一个进程就是一个运行实例–启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，这样的一个运行环境就叫做进程。</li>
<li>线程：线程不能单独存在，需要由进程来启动和管理。<br>
线程与进程的关系：</li>
</ul>
<ol>
<li>进程中任一线程执行出错，整个进程都会崩溃。</li>
<li>线程之间共享进程中的数据。</li>
<li>当一个进程关闭之后，操作系统会回收进程所占用的内存。</li>
<li>进程之间的内容相互隔离。</li>
</ol>
</blockquote>
<h3 id="三、单进程浏览器时代">三、单进程浏览器时代</h3>
<blockquote>
<p>单进程浏览器是指所有功能模块(网路、插件、JS运行环境、渲染引擎等)都是运行在同一个进程里，2007年以前，市面上浏览器都是单进程架构。<br>
这种结构模式：不稳定、不流畅、不安全。</p>
</blockquote>
<h3 id="四、多进程浏览器时代">四、多进程浏览器时代</h3>
<blockquote>
<ul>
<li>进程之间通过IPC机制进行通信</li>
<li>不稳定问题解决：由于进程的隔离性，当一个页面或插件崩溃时，不会影响到浏览器的其他页面</li>
<li>不流畅问题解决：即使JS的执行阻塞了渲染进程，也只是影响当前页面</li>
<li>不安全问题解决：安全沙箱<br>
最新的Chrome浏览器包括：<strong>一个浏览器主进程</strong>、<strong>一个GPU进程</strong>、<strong>一个网络进程</strong>、<strong>多个渲染进程</strong>和<strong>多个插件进程</strong>。<br>
存在问题：更高的资源占用和更复杂的体系结构。</li>
</ul>
</blockquote>
<h3 id="五、未来面向服务的架构">五、未来面向服务的架构</h3>
<blockquote>
<p>2016年，Chrome官方团队使用“面向服务的架构”(SOA)的思想设计了新的Chrome架构。</p>
</blockquote>
<h2 id="02-TCP协议：如何保证页面文件能被完整送达浏览器？">02 | TCP协议：如何保证页面文件能被完整送达浏览器？</h2>
<hr>
<blockquote>
<p>衡量web性能的一个重要指标叫&quot;FP(First Paint)&quot;,指页面加载到首次开始绘制的时长。影响FP的重要因素有一个网络加载速度。<br>
网络加载的过程就是数据包的传输过程，站在数据包角度，从“数据包如何送达主机”，“主机如何将数据包转交给应用”，“数据如何被完整送达应用程序”三个方面来分析。</p>
</blockquote>
<h3 id="一、IP：把数据包送达目的主机">一、IP：把数据包送达目的主机</h3>
<blockquote>
<ul>
<li>数据包要在互联网上进行传输，要符合<strong>网际协议IP(Internet Protocol)标准</strong>。</li>
<li>计算机的地址称为IP地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。</li>
<li>IP头是IP数据包开头的信息，包含IP版本、源IP地址、目标IP地址、生存时间等信息。</li>
</ul>
</blockquote>
<h3 id="二、UDP：把数据包送达应用程序">二、UDP：把数据包送达应用程序</h3>
<blockquote>
<p>IP是非常底层的协议，只负责把数据包传达给目标主机，但是并不知道交给哪个应用程序。<br>
因此需要基于IP之上开发能和应用打交道的协议，最常见的协议就是<strong>UDP协议–User Datagram Protocol(用户数据包协议)</strong><br>
UDP通过端口号把数据包分发给正确的程序。<br>
UDP可以校验数据是否正确，但是不提供重传机制，只是丢弃当前的包。虽然UDP不能保证数据的准确性，但是传输速度非常快。</p>
</blockquote>
<h3 id="三、TCP：把数据完整的送达应用程序">三、TCP：把数据完整的送达应用程序</h3>
<blockquote>
<p>TCP(Transition Control Protocol,传输控制协议)，是一种面向连接的、可靠的、基于字节流的传输层通信协议。<br>
TCP提供重传机制、引入了数据包排序机制。</p>
</blockquote>
<blockquote>
<p>一个完整的TCP连接的生命周期包含了“建立连接“、”传输数据“、“断开连接”三个阶段。<br>
建立连接阶段：这个阶段通过三次握手来建立客户端与服务端之间的连接，它们之间总共要发送三个数据包以确认连接的建立。<br>
传输数据阶段：该阶段，接收端需要对每个数据包进行确认操作。<br>
断开连接阶段：四次挥手来保证双方都能断开连接。</p>
</blockquote>
<h2 id="03｜HTTP请求流程：为什么很多站点第二次打开速度会很快">03｜HTTP请求流程：为什么很多站点第二次打开速度会很快</h2>
<hr>
<blockquote>
<p>HTTP协议是建立在TCP连接基础之上的。<br>
HTTP是一种允许浏览器向服务器获取资源的协议，是Web的基础。<br>
浏览器端发起HTTP请求流程如下：</p>
</blockquote>
<h3 id="一、构建请求">一、构建请求</h3>
<blockquote>
<p>浏览器构建请求行信息，构建好后，浏览器准备发起网络请求。</p>
</blockquote>
<h3 id="二、查找缓存">二、查找缓存</h3>
<blockquote>
<p>在准备发起网路请求阶段，浏览器偷偷的在它的缓存中查询是否有要请求的资源。<br>
若有：拦截请求，返回资源副本，直接结束请求。<br>
若缓存查找失败：继续下一步。</p>
</blockquote>
<h3 id="三、准备IP地址和端口号">三、准备IP地址和端口号</h3>
<blockquote>
<p>浏览器第一步会请求域名系统DNS返回域名对应的IP，如果没有特别指明端口号，则默认为80。 (浏览器提供了DNS数据缓存服务，若缓存过也就不会去请求，直接解析。从而减少一次网络请求)</p>
</blockquote>
<h3 id="四、等待TCP队列">四、等待TCP队列</h3>
<blockquote>
<p>拿到IP地址与端口号后，还需要在TCP队列中排队才能建立TCP连接。<br>
这是因为：Chrome有个机制，同一个域名同时最多只能建立6个TCP连接，若此刻同时有10个请求发生。则四个会进入TCP队列进行排队。 当然，若当前请求数量少于6个，则会直接进入下一步。</p>
</blockquote>
<h3 id="五、建立TCP连接">五、建立TCP连接</h3>
<blockquote>
<p>建立TCP连接，上一节我们已经知道，一个完整的TCP连接过程包括“建立连接”、“数据传输”、“断开连接“三个阶段。</p>
</blockquote>
<h3 id="六、发送HTTP请求">六、发送HTTP请求</h3>
<blockquote>
<p>HTTP请求是在TCP连接的数据传输阶段工作的，这个时候浏览器向服务器发送<em>请求行</em>，它包括请求方法、请求URI、HTTP版本协议。HTTP中的数据在这个通信过程中传输。</p>
</blockquote>
<h3 id="七、服务端处理HTTP请求流程">七、服务端处理HTTP请求流程</h3>
<blockquote>
<p>返回请求：通过 ‘curl -i domainName’命令，可以返回响应行(协议版本和状态码)、响应头(服务端返回请求的时间、Cookie、返回的数据类型等)、响应体信息.<br>
通常情况，一旦服务器向客户端返回了请求数据，它就要关闭TCP连接，但是如果浏览器或者服务器设置了Connection:keep-alive，那么TCP连接在发送后将仍保持打开状态。保持TCP连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。</p>
</blockquote>
<h3 id="八、问题解答">八、问题解答</h3>
<ol>
<li>为什么很多站点第二次打开速度会很快？</li>
</ol>
<blockquote>
<p>主要原因肯定是第一次加载页面的过程中，缓存了一些数据(从上面的过程分析，我们知道DNS缓存和页面资源缓存这两块数据是会被浏览器缓存起来的).<br>
网站把很多资源都缓存到了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。</p>
</blockquote>
<ol start="2">
<li>登录状态是如何保持的</li>
</ol>
<blockquote>
<p>简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。</p>
</blockquote>
<h2 id="04-导航流程：从输入URL到页面展示，这中间发生了什么？">04| 导航流程：从输入URL到页面展示，这中间发生了什么？</h2>
<blockquote>
<p>从输入URL到页面展示</p>
</blockquote>
<h3 id="1-用户输入">1.用户输入</h3>
<blockquote>
<p>如果是搜索内容，地址栏使用浏览器默认的搜索引擎合成带关键字的URL，如果符合URL规则，则合成完整的URL。</p>
</blockquote>
<h3 id="2-URL请求过程">2.URL请求过程</h3>
<blockquote>
<p>浏览器主进程通过进程间通信(IPC)把URL请求发送到网络进程，网络进程接收到URL请求后，会发起真正的URL请求。<br>
首先，浏览器会查找本地缓存是否缓存了该资源，如果缓存则直接返回资源给浏览器主进程，如果没有缓存，那么直接进入网络请求流程：请求前的第一步是DNS解析，用来获取域名对应的IP地址，如果是HTTPS协议，还需要建立TLS连接。<br>
接下来就是利用IP地址和服务器建立TCP连接，连接建立后，浏览器端会构建请求行、请求头等信息。<br>
服务器接收到请求信息后，根据请求信息生成响应行、响应头发给网络进程。网络进程接收到后，开始解析响应数据。</p>
</blockquote>
<h3 id="3-准备渲染进程">3.准备渲染进程</h3>
<blockquote>
<p>同一站点：协议相同、根域名相同。<br>
通常情况下，打开一个新的页面，浏览器就会为开辟一个新的渲染进程，但若从A页面打开的B页面，它们同属同一站点，那么使用同一渲染进程。</p>
</blockquote>
<h3 id="4-提交文档">4.提交文档</h3>
<blockquote>
<p>浏览器进程将网络进程接受到的HTML数据提交给渲染进程。</p>
</blockquote>
<h3 id="5-渲染阶段">5.渲染阶段</h3>
<blockquote>
<p>一旦文档被提交，渲染进程就开始页面解析和子资源加载了。</p>
</blockquote>
<h2 id="05-渲染流程-HTML、CSS和JAVASCRIPT是如何变成页面的？">05| 渲染流程:HTML、CSS和JAVASCRIPT是如何变成页面的？</h2>
<blockquote>
<p>按照渲染的时间顺序，流水线可以分为：构建DOM树、样式计算、布局计算、分层、绘制、分块、光栅化、合成。<br>
每个阶段需要关注：输入的内容、处理过程、输出的内容</p>
</blockquote>
<h3 id="1-构建DOM树">1.构建DOM树</h3>
<blockquote>
<p>因为浏览器无法直接理解和使用HTML，所以需要将HTML转换为浏览器能够理解的结构–DOM树。</p>
<ul>
<li>输入内容是HTML文件</li>
<li>经过HTML解析器解析</li>
<li>输出树状的DOM结构–DOM树结构与HTML内容几乎一模一样，但DOM是保存在内存中树状结构</li>
</ul>
</blockquote>
<h3 id="2-样式计算">2.样式计算</h3>
<blockquote>
<p>样式计算的目的是为了计算出DOM节点中每个元素的具体样式</p>
<ul>
<li>输入内容是CSS文件</li>
<li>处理过程是将CSS文件进行转换成浏览器可以理解的结构–styleSheets、对属性值进行标准化(em-px,red-rgb,bold-700)、计算DOM树中每个节点的样式属性(css继承和层叠规则)</li>
<li>输出了经过处理的styleSheets</li>
</ul>
</blockquote>
<h3 id="3-布局阶段">3.布局阶段</h3>
<blockquote>
<p>DOM结构有了、样式结构有了，需要对几何位置信息进行布局。</p>
<ul>
<li>创建布局树(DOM结构与样式结构结合，将display为none的去除，构成布局树)</li>
<li>布局计算(输入为布局树，经过复杂计算，输出也为布局树)、由于输入输出一致，因此Google下一代布局系统的优化叫做LayoutNG。</li>
</ul>
</blockquote>
<h3 id="4-分层">4.分层</h3>
<blockquote>
<p>页面开始绘制之前，浏览器会对3D变换、页面滚动、z-index等操作去为特定的节点生产专用的图层、并生成一颗对应的图层树。<br>
结果是：最终每一个节点都会直接或间接的从属于一个层。<br>
满足分层有两个条件：用于层叠上下文属性(定位属性、透明属性、滤镜等)和需要裁剪的地方(overflow)</p>
</blockquote>
<h3 id="5-图层绘制">5.图层绘制</h3>
<blockquote>
<p>将图层绘制命令拆分为很多小的绘制指令，然后一个个执行这些命令，汇总成待绘制列表。</p>
</blockquote>
<h3 id="6-栅格化操作">6.栅格化操作</h3>
<blockquote>
<p>有了这些绘制命令、浏览器渲染引擎中的合成线程进行绘制。<br>
所谓栅格化操作就是按照视口附近的图块优先生成位图。</p>
</blockquote>
<h3 id="7-合成和显示">7.合成和显示</h3>
<blockquote>
<p>浏览器进程通过via组件，接收合成线程发过来的绘制图块命令，将页面绘制到内存中，显示在屏幕上。</p>
</blockquote>
<h3 id="相关概念">相关概念</h3>
<h4 id="重排">重排</h4>
<blockquote>
<p>改变了元素长宽、浏览器会出发重新布局–后续一系列过程，会更新完成的渲染流水线，因此开销最大。</p>
</blockquote>
<h4 id="重绘">重绘</h4>
<blockquote>
<p>改变了颜色等未引起几何位置变化，重绘相较重排、省去了布局和分层阶段，因此效率会高一些。</p>
</blockquote>
<h4 id="直接合成">直接合成</h4>
<blockquote>
<p>比如CSS的transform实现的动画效果，可以避开重排和重绘阶段，大大提升绘制效率。</p>
</blockquote>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.3" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.3"><p><span>本文标题：</span>阶段一：宏观视角下的浏览器</p><p><span>文章作者：</span>六个周</p><p><span>发布时间：</span>2022-03-23</p><p><span>最后更新：</span>2022-03-24</p><p><span>原始链接：</span><a href="/A1阶段一：宏观视角下的浏览器/">https://blog.liugezhou.online/A1%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://blog.liugezhou.online/A1%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/"></i></span></p><p><span>版权声明：</span>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p></div><br><div class="tags"><a href="/tags/浏览器工作原理"><i class="fa fa-tag">浏览器工作原理</i></a></div><div class="post-nav"><a class="pre" href="/read001-%E4%B8%83%E5%A0%82%E6%9E%81%E7%AE%80%E7%89%A9%E7%90%86%E8%AF%BE/">七堂极简物理课</a><a class="next" href="/202211(3.14-3.20)/">每周小结(*48):七堂极简物理课</a></div><div id="vcomment"></div><script src="//code.bdstatic.com/npm/leancloud-storage@4.12.0/dist/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'Ci6gl5SnXOdXxv9BTlQx3T2F-gzGzoHsz',
  appKey:'bWsfs1hg9qURRp3gJ6SJU41x',
  placeholder:'ヾﾉ≧∀≦)o来啊，快活啊!',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 文章分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Web3/">Web3</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%84%9A%E6%89%8B%E6%9E%B6/">Web架构之脚手架</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%B0%8F%E6%8A%80/">前端小技</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">博客搭建</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/">服务端</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AF%8F%E5%91%A8%E5%B0%8F%E7%BB%93/">每周小结</a><span class="category-list-count">58</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">浏览器工作原理</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a><span class="category-list-count">5</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 其它主页</i></div><ul></ul><a href="https://github.com/liugezhou" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://twitter.com/liugezhou" title="Twitter" target="_blank">Twitter</a><ul></ul><a href="https://chat.liugezhou.online" title="自定义GPT" target="_blank">自定义GPT</a><ul></ul><a href="https://day.liugezhou.online" title="今日前端" target="_blank">今日前端</a><ul></ul><a href="https://run.liugezhou.online" title="Running" target="_blank">Running</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">六个周.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"></a><a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.3" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.3" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.3"><script type="text/javascript" src="/js/search.js?v=1.0.3"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/love.js?v=1.0.3"></script><script type="text/javascript" src="/js/copycode.js?v=1.0.3" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.3"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.3"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.3"></script></div></body></html>